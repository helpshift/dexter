#!/usr/bin/env python
#Copyright 2017 Helpshift Inc.

#Licensed under the Apache License, Version 2.0 (the "License");
#you may not use this file except in compliance with the License.
#You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0

#Unless required by applicable law or agreed to in writing, software
#distributed under the License is distributed on an "AS IS" BASIS,
#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#See the License for the specific language governing permissions and
#limitations under the License.

import os
import sys
import yaml
import zipfile
from contextlib import contextmanager
import shutil
import xml.dom.minidom
import argparse
import logging
import requests
import json


__VERSION__ = 1
MANIFEST_PACKAGE_NAME = 'com.unity3d.player'
STD_ANDROID_DIR = 'Assets/Plugins/Android'

PROJECT_PROPERTIES_CONTENT = """# Automatically generated by dexter tool

target = {0}
android.library = true
"""


def log_level(verbosity):
    if verbosity == 1:
        return logging.INFO
    if verbosity > 1:
        return logging.DEBUG
    return logging.WARN


@contextmanager
def open_zip(filepath):
    with open(filepath) as f:
        yield zipfile.ZipFile(f)


def filter_paths_by_ext(paths, ext):
    """Filter file paths that match a specific extension

    :param iterable paths: all paths to consider
    :param str ext: required file extension
    :returns: generator that yields paths that match the ext
    :rtype: generator object

    """
    return (x for x in paths if os.path.splitext(x)[1] == ext)


def is_android_enabled(meta_filepath):
    """Check if Android platform is enabled for a unity meta file

    :param str meta_filepath: path to the meta file
    :returns: whether android platform is enabled
    :rtype: bool

    """
    with open(meta_filepath) as f:
        data = yaml.load(f)
        is_enabled = data.get('PluginImporter', {}) \
                         .get('platformData', {}) \
                         .get('Android', {}) \
                         .get('enabled', 0)
        return is_enabled == 1


def meta_file(filepath):
    return '{0}.meta'.format(filepath)


def std_dir(project_dir):
    return os.path.join(project_dir, *STD_ANDROID_DIR.split(os.path.sep))


def is_same_relpath(relpath, path):
    path_parts = path.split(os.path.sep)
    relpath_parts = relpath.split(os.path.sep)
    return os.path.join(*path_parts[-len(relpath_parts):]) == relpath


def is_std_dir(path):
    """Check if a given directory is the std android lib dir

    :param str path: path to the directory
    :returns: if it's the std android lib dir
    :rtype: bool

    """
    return is_same_relpath(STD_ANDROID_DIR, path)


def is_std_lib_dir(path):
    libs_relpath = os.path.join(STD_ANDROID_DIR, 'libs')
    return is_same_relpath(libs_relpath, path)


def has_empty_res(lib_path):
    """Check if a library has non-existing or empty res/ dir

    :param str lib_path: path to the lib directory
    :returns: whether it has empty resources
    :rtype: bool

    """
    res_path = os.path.join(lib_path, 'res')
    if os.path.exists(res_path):
        return len(os.listdir(res_path)) == 0
    return True


def move_lib_file(src, dst_dir):
    """Move a unity lib file from one location to other

    :param str src: path to a lib file
    :param str dst_dir: path to the target dir, to move the file to
    :returns: abs destination path
    :rtype: str

    """
    dst = os.path.join(dst_dir, os.path.basename(src))
    if os.path.exists(dst):
        raise Exception('Path "{0}" already exists'.format(dst))
    logging.debug((
        'Moving lib from "{0}" to "{1}"'
    ).format(src, dst_dir))
    shutil.move(src, dst_dir)

    meta_file_path = meta_file(src)
    logging.debug('Deleting meta file "{0}"'.format(meta_file_path))
    os.remove(meta_file_path)
    return dst


def modify_manifest_file(path, package_name):
    """Modify manifest package name in AndroidManifest.xml file

    This will,

      1. change the package name of the manifest node of the xml
         to the provided package_name

      2. Make sure that the activity, service, provider, receiver
         nodes under application have a fully qualified android:name
         attribute

    :param str path: path to the manifest file
    :param str package_name: name of the package to update to
    :returns: None
    :rtype: NoneType

    """
    xmldoc = xml.dom.minidom.parse(path)
    m = xmldoc.getElementsByTagName('manifest')[0]
    orig_pkg = m.getAttribute('package')
    m.setAttribute('package', package_name)

    app_nodes = m.getElementsByTagName('application')
    assert len(app_nodes) in {0, 1}
    if len(app_nodes) == 1:
        app_tags = {'activity', 'service', 'provider', 'receiver'}
        app_children = [c for c in app_nodes[0].childNodes
                        if c.nodeName in app_tags]
        for n in app_children:
            android_name = n.getAttribute('android:name')
            if android_name.startswith('.'):
                fqn = '{0}{1}'.format(orig_pkg, android_name)
                n.setAttribute('android:name', fqn)

    logging.debug('Modifying "{0}"'.format(path))
    with open(path, 'w') as f:
        f.write(xmldoc.toxml())


def ensure_project_properties(filepath, android_target):
    """Ensure a project.properties file exists at a path

    Note that if the project.properties file exists, it won't be
    checked for the specified android_target.

    :param str filepath: path to the project.properties file
    :param str android_target: android target to add if the file needs
                               to be created
    :returns: None

    """
    if not os.path.exists(filepath):
        with open(filepath, 'w') as f:
            f.write(PROJECT_PROPERTIES_CONTENT.format(android_target))


class AndroidLib(object):

    def __init__(self, path):
        self.path = path
        self.basename = os.path.basename(path)

    def __repr__(self):
        return '<{0}(name="{1}")>'.format(self.__class__.__name__,
                                          self.basename)


class JARLib(AndroidLib):

    @classmethod
    def factory(cls, filepaths):
        return (cls(p) for p in filter_paths_by_ext(filepaths, '.jar')
                if not is_std_dir(os.path.dirname(p))
                and not is_std_lib_dir(os.path.dirname(p))
                and is_android_enabled(meta_file(p)))

    def process(self, project_dir):
        return move_lib_file(self.path, std_dir(project_dir))


class AndroidProjectLib(AndroidLib):

    @staticmethod
    def is_library(dirpath):
        f = lambda x: os.path.exists(os.path.join(dirpath, x))
        return f('AndroidManifest.xml') and f('project.properties')

    @classmethod
    def factory(cls, dirpaths):
        for path in dirpaths:
            if is_std_dir(path):
                continue
            if AndroidProjectLib.is_library(path) and has_empty_res(path):
                yield cls(path)

    def process(self, project_dir):
        manifest_file = os.path.join(self.path, 'AndroidManifest.xml')
        modify_manifest_file(manifest_file, MANIFEST_PACKAGE_NAME)


class AARLib(AndroidLib):

    def __init__(self, path, android_target):
        super(AARLib, self).__init__(path)
        self.android_target = android_target

    @staticmethod
    def has_empty_res(filepath):
        with open_zip(filepath) as z:
            res = [x for x in z.namelist() if x.startswith('res/')]
            return len(res) in {0, 1}

    @classmethod
    def factory(cls, paths, android_target):
        return (cls(x, android_target)
                for x in filter_paths_by_ext(paths, '.aar')
                if is_android_enabled(meta_file(x))
                and AARLib.has_empty_res(x))

    def process(self, project_dir):
        # Skip moving the file if it's in the android std dir already
        android_std_dir = std_dir(project_dir)
        aar_path = self.path
        if os.path.dirname(self.path) != android_std_dir:
            aar_path = move_lib_file(self.path, std_dir(project_dir))
        ext_to = os.path.join(std_dir(project_dir),
                              os.path.splitext(os.path.basename(aar_path))[0])
        z = zipfile.ZipFile(aar_path)
        logging.debug('Extracting aar to "{0}"'.format(ext_to))
        z.extractall(path=ext_to)

        # modify manifest file
        manifest_file = os.path.join(ext_to, 'AndroidManifest.xml')
        modify_manifest_file(manifest_file, MANIFEST_PACKAGE_NAME)

        # Ensure project.properties file
        proj_prop_file = os.path.join(ext_to, 'project.properties')
        ensure_project_properties(proj_prop_file, self.android_target)

        # Move jar files under unpacked aar to libs
        jar_files = filter_paths_by_ext(os.listdir(ext_to), '.jar')
        aar_libs_dir = os.path.join(ext_to, 'libs')
        if not os.path.exists(aar_libs_dir):
            os.mkdir(aar_libs_dir)
        assert os.path.isdir(aar_libs_dir)
        for x in jar_files:
            shutil.move(os.path.join(ext_to, x), os.path.join(aar_libs_dir, x))

        logging.debug('Deleting aar "{0}"'.format(aar_path))
        os.remove(aar_path)


def discover_libs(ctx, root_dir):
    """Discover modifiable android libs under root_dir

    :param object ctx: context passed down from parsed CLI args
    :param root_dir: path to a directory, typically the Assets/ dir
    :returns: generator object that yields AndroidLib objects lazily
    :rtype: generator

    """
    for root, dirs, files in os.walk(root_dir, topdown=True):
        filepaths = [os.path.join(root, x) for x in files]
        dirpaths = [os.path.join(root, x) for x in dirs]

        lib_dirs = list(AndroidProjectLib.factory(dirpaths))
        for d in lib_dirs:
            yield d

        aars = AARLib.factory(filepaths, ctx.android_target)
        for aar in aars:
            yield aar

        jars = JARLib.factory(filepaths)
        for jar in jars:
            yield jar

        lib_dir_names = set([os.path.basename(d.path) for d in lib_dirs])

        # now we no longer need to recursively walk into discovered
        # lib dirs
        for i, d in enumerate(dirs):
            if d in lib_dir_names:
                del dirs[i]


def create_backup(dirpath, suffix):
    bkp_dir_name = '{0}{1}'.format(os.path.basename(dirpath), suffix)
    dst_dir = os.path.join(os.path.dirname(dirpath), bkp_dir_name)
    logging.debug('Creating backup of "{0}" at "{1}"'.format(dirpath, dst_dir))
    shutil.copytree(dirpath, dst_dir)
    return dst_dir

def script_update_available() :
    logging.info('Checking for updates...')

    try:
        # Get properties file from git
        url = 'https://raw.githubusercontent.com/helpshift/dexter/master/properties'
        propertiesData = requests.get(url)

        # raise exception for failed request.
        propertiesData.raise_for_status()

        # Load text as json
        remoteVersion = propertiesData.json()['version']

        # Check the current version is the latest
        return __VERSION__ < remoteVersion
    except Exception, e:
        logging.info('Script update check encountered error : ' + str(e))
        return False

def main(args):

    # Exit if script update is available
    scriptUpdateAvailable = script_update_available()
    if scriptUpdateAvailable:
        # Terminate since we want to script to run only if its the latest version
        logging.info('New version available. Please download the latest version from https://github.com/helpshift/dexter')
        sys.exit(1)

    assets_dir = os.path.join(args.project_dir, 'Assets')
    create_backup(assets_dir, args.backup_suffix)
    # Here we want result of discover_libs to be non-lazy as
    # processing involves creation of new dirs etc.
    for lib in list(discover_libs(args, assets_dir)):
        logging.info('Processing "{0}"'.format(lib.path))
        lib.process(args.project_dir)
    return 0


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-v', '--verbose', default=1, action='count')
    parser.add_argument('-p', '--project-dir', default=os.getcwd(),
                        help='Path to the project directory [Default: pwd]')
    parser.add_argument('-b', '--backup-suffix', default='.bkp',
                        help=(
                            'Suffix to add to dir where backup is taken '
                            '[Default: .bkp]'
                        ))
    parser.add_argument('-a', '--android-target', default='android-23',
                        help='Android target [Default: android-23]')
    args = parser.parse_args()
    logging.basicConfig(stream=sys.stderr, level=log_level(args.verbose))
    sys.exit(main(args))
